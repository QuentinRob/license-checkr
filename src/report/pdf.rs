use std::path::Path;

use anyhow::{Context, Result};
use plotters::prelude::*;
use printpdf::{
    BuiltinFont, Image, ImageTransform, Line, Mm, PdfDocument, PdfDocumentReference,
    PdfLayerIndex, PdfLayerReference, PdfPageIndex, Point,
};

use crate::models::{Dependency, Ecosystem, LicenseRisk, PolicyVerdict};

const PAGE_WIDTH: f32 = 210.0;
const PAGE_HEIGHT: f32 = 297.0;
const MARGIN: f32 = 20.0;

/// Render a PDF report with cover page, charts page, and full dependency table.
pub fn render(deps: &[Dependency], project_path: &Path, output_path: &Path) -> Result<()> {
    let doc = PdfDocument::empty("License Report");

    add_cover_page(&doc, deps, project_path)?;
    add_charts_page(&doc, deps)?;
    add_table_pages(&doc, deps)?;

    let bytes = doc.save_to_bytes()?;
    std::fs::write(output_path, &bytes)
        .with_context(|| format!("Failed to write PDF to {}", output_path.display()))?;

    println!("PDF report written to: {}", output_path.display());
    Ok(())
}

fn add_cover_page(doc: &PdfDocumentReference, deps: &[Dependency], project_path: &Path) -> Result<()> {
    let (page_idx, layer_idx) = doc.add_page(Mm(PAGE_WIDTH), Mm(PAGE_HEIGHT), "Cover");
    let layer = doc.get_page(page_idx).get_layer(layer_idx);

    let font = doc.add_builtin_font(BuiltinFont::HelveticaBold)?;
    let font_regular = doc.add_builtin_font(BuiltinFont::Helvetica)?;

    let total = deps.len();
    let pass = deps.iter().filter(|d| d.verdict == PolicyVerdict::Pass).count();
    let warn = deps.iter().filter(|d| d.verdict == PolicyVerdict::Warn).count();
    let error = deps.iter().filter(|d| d.verdict == PolicyVerdict::Error).count();

    let now = chrono_now();

    // Title
    layer.use_text("License Compliance Report", 28.0, Mm(MARGIN), Mm(260.0), &font);

    // Project path
    layer.use_text(
        format!("Project: {}", project_path.display()),
        11.0,
        Mm(MARGIN),
        Mm(245.0),
        &font_regular,
    );

    // Date
    layer.use_text(
        format!("Scan date: {}", now),
        11.0,
        Mm(MARGIN),
        Mm(238.0),
        &font_regular,
    );

    // Divider line
    let line = Line {
        points: vec![
            (Point::new(Mm(MARGIN), Mm(233.0)), false),
            (Point::new(Mm(PAGE_WIDTH - MARGIN), Mm(233.0)), false),
        ],
        is_closed: false,
    };
    layer.add_line(line);

    // Summary stats
    layer.use_text("Summary", 16.0, Mm(MARGIN), Mm(222.0), &font);

    let stats = [
        ("Total dependencies", total.to_string()),
        ("Pass", pass.to_string()),
        ("Warn", warn.to_string()),
        ("Error", error.to_string()),
    ];

    let mut y = 210.0f32;
    for (label, value) in &stats {
        layer.use_text(
            format!("{}: {}", label, value),
            12.0,
            Mm(MARGIN + 5.0),
            Mm(y),
            &font_regular,
        );
        y -= 8.0;
    }

    // Version
    layer.use_text(
        format!("Generated by license-checkr v{}", env!("CARGO_PKG_VERSION")),
        9.0,
        Mm(MARGIN),
        Mm(10.0),
        &font_regular,
    );

    Ok(())
}

fn add_charts_page(doc: &PdfDocumentReference, deps: &[Dependency]) -> Result<()> {
    let (page_idx, layer_idx) = doc.add_page(Mm(PAGE_WIDTH), Mm(PAGE_HEIGHT), "Charts");
    let layer = doc.get_page(page_idx).get_layer(layer_idx);

    let font = doc.add_builtin_font(BuiltinFont::HelveticaBold)?;
    layer.use_text("License Distribution", 18.0, Mm(MARGIN), Mm(275.0), &font);

    // Risk distribution bar chart
    let risk_png = render_risk_bar_chart(deps)?;
    embed_png_image(doc, &layer, &risk_png, Mm(MARGIN), Mm(150.0), Mm(80.0), Mm(100.0))?;

    // Ecosystem distribution bar chart
    let eco_png = render_ecosystem_bar_chart(deps)?;
    embed_png_image(doc, &layer, &eco_png, Mm(PAGE_WIDTH / 2.0 + 5.0), Mm(150.0), Mm(80.0), Mm(100.0))?;

    let font_regular = doc.add_builtin_font(BuiltinFont::Helvetica)?;
    layer.use_text("Risk Distribution", 10.0, Mm(MARGIN), Mm(148.0), &font_regular);
    layer.use_text(
        "Ecosystem Distribution",
        10.0,
        Mm(PAGE_WIDTH / 2.0 + 5.0),
        Mm(148.0),
        &font_regular,
    );

    Ok(())
}

fn add_table_pages(doc: &PdfDocumentReference, deps: &[Dependency]) -> Result<()> {
    let font = doc.add_builtin_font(BuiltinFont::HelveticaBold)?;
    let font_regular = doc.add_builtin_font(BuiltinFont::Helvetica)?;

    const ROW_HEIGHT: f32 = 6.5;
    const HEADER_Y: f32 = 270.0;
    const FIRST_ROW_Y: f32 = 262.0;
    const BOTTOM_MARGIN: f32 = 15.0;

    let col_x = [MARGIN, MARGIN + 55.0, MARGIN + 95.0, MARGIN + 120.0, MARGIN + 150.0];
    let headers = ["Name", "Version", "Ecosystem", "License", "Verdict"];

    let mut current_y = FIRST_ROW_Y;
    let mut page_opt: Option<(PdfPageIndex, PdfLayerIndex)> = None;

    let get_or_create_page = |doc: &PdfDocumentReference, y: &mut f32, page_opt: &mut Option<(PdfPageIndex, PdfLayerIndex)>| -> Result<PdfLayerReference> {
        if page_opt.is_none() || *y < BOTTOM_MARGIN {
            let (pi, li) = doc.add_page(Mm(PAGE_WIDTH), Mm(PAGE_HEIGHT), "Deps");
            let layer = doc.get_page(pi).get_layer(li);
            // Header row
            for (i, header) in headers.iter().enumerate() {
                layer.use_text(*header, 9.0, Mm(col_x[i]), Mm(HEADER_Y), &font);
            }
            *y = FIRST_ROW_Y;
            *page_opt = Some((pi, li));
            Ok(layer)
        } else {
            let (pi, li) = page_opt.unwrap();
            Ok(doc.get_page(pi).get_layer(li))
        }
    };

    for dep in deps {
        let layer = get_or_create_page(doc, &mut current_y, &mut page_opt)?;

        let license = dep
            .license_spdx
            .as_deref()
            .or(dep.license_raw.as_deref())
            .unwrap_or("unknown");

        let verdict_str = match dep.verdict {
            PolicyVerdict::Pass => "pass",
            PolicyVerdict::Warn => "warn",
            PolicyVerdict::Error => "error",
        };

        let name_display = if dep.name.len() > 28 {
            format!("{}...", &dep.name[..25])
        } else {
            dep.name.clone()
        };

        let license_display = if license.len() > 18 {
            format!("{}...", &license[..15])
        } else {
            license.to_string()
        };

        let row_data = [
            name_display,
            dep.version.clone(),
            dep.ecosystem.to_string(),
            license_display,
            verdict_str.to_string(),
        ];

        for (i, cell) in row_data.iter().enumerate() {
            layer.use_text(cell.as_str(), 8.0, Mm(col_x[i]), Mm(current_y), &font_regular);
        }

        current_y -= ROW_HEIGHT;

        if current_y < BOTTOM_MARGIN {
            page_opt = None;
        }
    }

    Ok(())
}

fn render_risk_bar_chart(deps: &[Dependency]) -> Result<Vec<u8>> {
    let categories = [
        ("Permissive", LicenseRisk::Permissive),
        ("Weak CL", LicenseRisk::WeakCopyleft),
        ("Strong CL", LicenseRisk::StrongCopyleft),
        ("Proprietary", LicenseRisk::Proprietary),
        ("Unknown", LicenseRisk::Unknown),
    ];

    let counts: Vec<(&str, u32)> = categories
        .iter()
        .map(|(label, risk)| {
            let count = deps.iter().filter(|d| &d.risk == risk).count() as u32;
            (*label, count)
        })
        .collect();

    render_bar_chart(&counts, "Risk Distribution")
}

fn render_ecosystem_bar_chart(deps: &[Dependency]) -> Result<Vec<u8>> {
    let categories = [
        ("Rust", Ecosystem::Rust),
        ("Python", Ecosystem::Python),
        ("Java", Ecosystem::Java),
        ("Node", Ecosystem::Node),
    ];

    let counts: Vec<(&str, u32)> = categories
        .iter()
        .map(|(label, eco)| {
            let count = deps.iter().filter(|d| &d.ecosystem == eco).count() as u32;
            (*label, count)
        })
        .collect();

    render_bar_chart(&counts, "Ecosystem Distribution")
}

fn render_bar_chart(data: &[(&str, u32)], title: &str) -> Result<Vec<u8>> {
    const W: u32 = 400;
    const H: u32 = 300;

    let mut buf = vec![0u8; (W * H * 3) as usize];

    {
        let root = BitMapBackend::with_buffer(&mut buf, (W, H)).into_drawing_area();
        root.fill(&WHITE)?;

        let max_val = data.iter().map(|(_, v)| *v).max().unwrap_or(1).max(1);

        let mut chart = ChartBuilder::on(&root)
            .caption(title, ("sans-serif", 16))
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(40)
            .build_cartesian_2d(0..data.len(), 0u32..max_val + 1)?;

        chart
            .configure_mesh()
            .x_labels(data.len())
            .x_label_formatter(&|idx| {
                data.get(*idx).map(|(l, _)| l.to_string()).unwrap_or_default()
            })
            .draw()?;

        chart.draw_series(data.iter().enumerate().map(|(i, (_, count))| {
            let color = match i {
                0 => RGBColor(0x2e, 0xa0, 0x44), // green
                1 => RGBColor(0xd2, 0x93, 0x22), // yellow
                2 => RGBColor(0xd7, 0x3a, 0x4a), // red
                3 => RGBColor(0x89, 0x29, 0xa8), // purple
                _ => RGBColor(0x80, 0x80, 0x80), // grey
            };
            Rectangle::new([(i, 0), (i + 1, *count)], color.filled())
        }))?;

        root.present()?;
    }

    // Convert RGB buffer â†’ PNG bytes
    let img = ::image::RgbImage::from_raw(W, H, buf)
        .context("Failed to create image from chart buffer")?;
    let dyn_img = ::image::DynamicImage::ImageRgb8(img);

    let mut png_bytes = Vec::new();
    dyn_img.write_to(
        &mut std::io::Cursor::new(&mut png_bytes),
        ::image::ImageOutputFormat::Png,
    )?;

    Ok(png_bytes)
}

fn embed_png_image(
    _doc: &PdfDocumentReference,
    layer: &PdfLayerReference,
    png_bytes: &[u8],
    x: Mm,
    y: Mm,
    width: Mm,
    height: Mm,
) -> Result<()> {
    let dyn_img = ::image::load_from_memory(png_bytes)?;
    let (img_w, img_h) = (dyn_img.width() as f32, dyn_img.height() as f32);

    let scale_x = width.0 / img_w;
    let scale_y = height.0 / img_h;

    let image = Image::from_dynamic_image(&dyn_img);
    image.add_to_layer(
        layer.clone(),
        ImageTransform {
            translate_x: Some(x),
            translate_y: Some(y),
            scale_x: Some(scale_x),
            scale_y: Some(scale_y),
            dpi: Some(150.0),
            ..Default::default()
        },
    );

    Ok(())
}

/// Return a simple date string. Using a manual approach to avoid a chrono dependency.
fn chrono_now() -> String {
    // Use std::time to get a unix timestamp and format it simply
    use std::time::{SystemTime, UNIX_EPOCH};
    let secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_secs())
        .unwrap_or(0);

    // Convert unix timestamp to Y-M-D (approximate, ignores leap seconds)
    let days_since_epoch = secs / 86400;
    let year = 1970 + days_since_epoch / 365;
    let day_of_year = days_since_epoch % 365;
    let month = (day_of_year / 30) + 1;
    let day = (day_of_year % 30) + 1;

    format!("{:04}-{:02}-{:02}", year, month.min(12), day.min(31))
}
